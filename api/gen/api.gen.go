// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.3.0 DO NOT EDIT.
package gen

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	BasicAuthScopes = "basicAuth.Scopes"
)

// Defines values for Status.
const (
	Expired Status = "expired"
	Failed  Status = "failed"
	Pending Status = "pending"
	Success Status = "success"
)

// CreateSignRequest defines model for CreateSignRequest.
type CreateSignRequest struct {
	HolderId    string  `json:"holder_id"`
	HolderName  string  `json:"holder_name"`
	Issue       []Issue `json:"issue"`
	Notes       *string `json:"notes,omitempty"`
	RequestUser string  `json:"request_user"`
}

// CreateSignResponse defines model for CreateSignResponse.
type CreateSignResponse struct {
	Interfaces *[]NetworkInterface `json:"interfaces,omitempty"`
	RequestId  *string             `json:"request_id,omitempty"`
	Token      *string             `json:"token,omitempty"`
}

// Issue defines model for Issue.
type Issue struct {
	Copy        int     `json:"copy"`
	Description *string `json:"description,omitempty"`
	Number      string  `json:"number"`
}

// NetworkInterface defines model for NetworkInterface.
type NetworkInterface struct {
	Dsn  *string `json:"dsn,omitempty"`
	Ip   *string `json:"ip,omitempty"`
	Name *string `json:"name,omitempty"`
}

// SignResponse defines model for SignResponse.
type SignResponse struct {
	CreatedAt         *time.Time `json:"created_at,omitempty"`
	HolderId          string     `json:"holder_id"`
	HolderName        string     `json:"holder_name"`
	Issue             []Issue    `json:"issue"`
	LocationLatitude  *float32   `json:"location_latitude,omitempty"`
	LocationLongitude *float32   `json:"location_longitude,omitempty"`
	Notes             *string    `json:"notes,omitempty"`
	RequestId         *string    `json:"request_id,omitempty"`
	RequestUser       string     `json:"request_user"`

	// Sign Base64 encoded signing data.
	Sign      *string    `json:"sign,omitempty"`
	SignedAt  *time.Time `json:"signed_at,omitempty"`
	Status    *Status    `json:"status,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// SignSubmitRequest defines model for SignSubmitRequest.
type SignSubmitRequest struct {
	LocationLatitude  *float32 `json:"location_latitude,omitempty"`
	LocationLongitude *float32 `json:"location_longitude,omitempty"`

	// Sign Base64 encoded signing data.
	Sign string `json:"sign"`
}

// Status defines model for Status.
type Status string

// RequestID defines model for RequestID.
type RequestID = string

// Token defines model for Token.
type Token = string

// XPortierAgent defines model for XPortierAgent.
type XPortierAgent = string

// PostKeyOtgSignParams defines parameters for PostKeyOtgSign.
type PostKeyOtgSignParams struct {
	XPortierAgent XPortierAgent `json:"X-Portier-Agent"`
}

// GetKeyOtgSignRequestIDParams defines parameters for GetKeyOtgSignRequestID.
type GetKeyOtgSignRequestIDParams struct {
	// Token Token to get access for this request
	Token         Token         `form:"token" json:"token"`
	XPortierAgent XPortierAgent `json:"X-Portier-Agent"`
}

// PostKeyOtgSignRequestIDParams defines parameters for PostKeyOtgSignRequestID.
type PostKeyOtgSignRequestIDParams struct {
	// Token Token to get access for this request
	Token Token `form:"token" json:"token"`
}

// GetKeyOtgSignRequestIDQrParams defines parameters for GetKeyOtgSignRequestIDQr.
type GetKeyOtgSignRequestIDQrParams struct {
	// Token Token to get access for this request
	Token         Token         `form:"token" json:"token"`
	XPortierAgent XPortierAgent `json:"X-Portier-Agent"`
}

// PostKeyOtgSignJSONRequestBody defines body for PostKeyOtgSign for application/json ContentType.
type PostKeyOtgSignJSONRequestBody = CreateSignRequest

// PostKeyOtgSignRequestIDJSONRequestBody defines body for PostKeyOtgSignRequestID for application/json ContentType.
type PostKeyOtgSignRequestIDJSONRequestBody = SignSubmitRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List sign requests
	// (GET /key-otg/sign)
	GetKeyOtgSign(ctx echo.Context) error
	// Create a new signing request
	// (POST /key-otg/sign)
	PostKeyOtgSign(ctx echo.Context, params PostKeyOtgSignParams) error
	// Get signed request
	// (GET /key-otg/sign/{requestID})
	GetKeyOtgSignRequestID(ctx echo.Context, requestID RequestID, params GetKeyOtgSignRequestIDParams) error
	// Sign the request
	// (POST /key-otg/sign/{requestID})
	PostKeyOtgSignRequestID(ctx echo.Context, requestID RequestID, params PostKeyOtgSignRequestIDParams) error
	// Get QR code for this request
	// (GET /key-otg/sign/{requestID}/qr)
	GetKeyOtgSignRequestIDQr(ctx echo.Context, requestID RequestID, params GetKeyOtgSignRequestIDQrParams) error
	// Shutdown the server
	// (POST /shutdown)
	PostShutdown(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetKeyOtgSign converts echo context to params.
func (w *ServerInterfaceWrapper) GetKeyOtgSign(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKeyOtgSign(ctx)
	return err
}

// PostKeyOtgSign converts echo context to params.
func (w *ServerInterfaceWrapper) PostKeyOtgSign(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostKeyOtgSignParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Portier-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Portier-Agent")]; found {
		var XPortierAgent XPortierAgent
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Portier-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Portier-Agent", valueList[0], &XPortierAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Portier-Agent: %s", err))
		}

		params.XPortierAgent = XPortierAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Portier-Agent is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostKeyOtgSign(ctx, params)
	return err
}

// GetKeyOtgSignRequestID converts echo context to params.
func (w *ServerInterfaceWrapper) GetKeyOtgSignRequestID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "requestID" -------------
	var requestID RequestID

	err = runtime.BindStyledParameterWithOptions("simple", "requestID", ctx.Param("requestID"), &requestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestID: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeyOtgSignRequestIDParams
	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Portier-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Portier-Agent")]; found {
		var XPortierAgent XPortierAgent
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Portier-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Portier-Agent", valueList[0], &XPortierAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Portier-Agent: %s", err))
		}

		params.XPortierAgent = XPortierAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Portier-Agent is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKeyOtgSignRequestID(ctx, requestID, params)
	return err
}

// PostKeyOtgSignRequestID converts echo context to params.
func (w *ServerInterfaceWrapper) PostKeyOtgSignRequestID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "requestID" -------------
	var requestID RequestID

	err = runtime.BindStyledParameterWithOptions("simple", "requestID", ctx.Param("requestID"), &requestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestID: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PostKeyOtgSignRequestIDParams
	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostKeyOtgSignRequestID(ctx, requestID, params)
	return err
}

// GetKeyOtgSignRequestIDQr converts echo context to params.
func (w *ServerInterfaceWrapper) GetKeyOtgSignRequestIDQr(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "requestID" -------------
	var requestID RequestID

	err = runtime.BindStyledParameterWithOptions("simple", "requestID", ctx.Param("requestID"), &requestID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestID: %s", err))
	}

	ctx.Set(BasicAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetKeyOtgSignRequestIDQrParams
	// ------------- Required query parameter "token" -------------

	err = runtime.BindQueryParameter("form", true, true, "token", ctx.QueryParams(), &params.Token)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter token: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-Portier-Agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Portier-Agent")]; found {
		var XPortierAgent XPortierAgent
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-Portier-Agent, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Portier-Agent", valueList[0], &XPortierAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-Portier-Agent: %s", err))
		}

		params.XPortierAgent = XPortierAgent
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-Portier-Agent is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetKeyOtgSignRequestIDQr(ctx, requestID, params)
	return err
}

// PostShutdown converts echo context to params.
func (w *ServerInterfaceWrapper) PostShutdown(ctx echo.Context) error {
	var err error

	ctx.Set(BasicAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostShutdown(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/key-otg/sign", wrapper.GetKeyOtgSign)
	router.POST(baseURL+"/key-otg/sign", wrapper.PostKeyOtgSign)
	router.GET(baseURL+"/key-otg/sign/:requestID", wrapper.GetKeyOtgSignRequestID)
	router.POST(baseURL+"/key-otg/sign/:requestID", wrapper.PostKeyOtgSignRequestID)
	router.GET(baseURL+"/key-otg/sign/:requestID/qr", wrapper.GetKeyOtgSignRequestIDQr)
	router.POST(baseURL+"/shutdown", wrapper.PostShutdown)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
